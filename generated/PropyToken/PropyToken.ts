// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class UpgradeProposal extends ethereum.Event {
  get params(): UpgradeProposal__Params {
    return new UpgradeProposal__Params(this);
  }
}

export class UpgradeProposal__Params {
  _event: UpgradeProposal;

  constructor(event: UpgradeProposal) {
    this._event = event;
  }

  get newVersion(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class Transfer extends ethereum.Event {
  get params(): Transfer__Params {
    return new Transfer__Params(this);
  }
}

export class Transfer__Params {
  _event: Transfer;

  constructor(event: Transfer) {
    this._event = event;
  }

  get from(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get to(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get value(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Approval extends ethereum.Event {
  get params(): Approval__Params {
    return new Approval__Params(this);
  }
}

export class Approval__Params {
  _event: Approval;

  constructor(event: Approval) {
    this._event = event;
  }

  get from(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get spender(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get value(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class PropyToken extends ethereum.SmartContract {
  static bind(address: Address): PropyToken {
    return new PropyToken("PropyToken", address);
  }

  multiAsset(): Address {
    let result = super.call("multiAsset", "multiAsset():(address)", []);

    return result[0].toAddress();
  }

  try_multiAsset(): ethereum.CallResult<Address> {
    let result = super.tryCall("multiAsset", "multiAsset():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  name(): string {
    let result = super.call("name", "name():(string)", []);

    return result[0].toString();
  }

  try_name(): ethereum.CallResult<string> {
    let result = super.tryCall("name", "name():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  approve(_spender: Address, _value: BigInt): boolean {
    let result = super.call("approve", "approve(address,uint256):(bool)", [
      ethereum.Value.fromAddress(_spender),
      ethereum.Value.fromUnsignedBigInt(_value)
    ]);

    return result[0].toBoolean();
  }

  try_approve(_spender: Address, _value: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall("approve", "approve(address,uint256):(bool)", [
      ethereum.Value.fromAddress(_spender),
      ethereum.Value.fromUnsignedBigInt(_value)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  commitUpgrade(): boolean {
    let result = super.call("commitUpgrade", "commitUpgrade():(bool)", []);

    return result[0].toBoolean();
  }

  try_commitUpgrade(): ethereum.CallResult<boolean> {
    let result = super.tryCall("commitUpgrade", "commitUpgrade():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  getLatestVersion(): Address {
    let result = super.call(
      "getLatestVersion",
      "getLatestVersion():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_getLatestVersion(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getLatestVersion",
      "getLatestVersion():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  _forwardTransferFromWithReference(
    _from: Address,
    _to: Address,
    _value: BigInt,
    _reference: string,
    _sender: Address
  ): boolean {
    let result = super.call(
      "_forwardTransferFromWithReference",
      "_forwardTransferFromWithReference(address,address,uint256,string,address):(bool)",
      [
        ethereum.Value.fromAddress(_from),
        ethereum.Value.fromAddress(_to),
        ethereum.Value.fromUnsignedBigInt(_value),
        ethereum.Value.fromString(_reference),
        ethereum.Value.fromAddress(_sender)
      ]
    );

    return result[0].toBoolean();
  }

  try__forwardTransferFromWithReference(
    _from: Address,
    _to: Address,
    _value: BigInt,
    _reference: string,
    _sender: Address
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "_forwardTransferFromWithReference",
      "_forwardTransferFromWithReference(address,address,uint256,string,address):(bool)",
      [
        ethereum.Value.fromAddress(_from),
        ethereum.Value.fromAddress(_to),
        ethereum.Value.fromUnsignedBigInt(_value),
        ethereum.Value.fromString(_reference),
        ethereum.Value.fromAddress(_sender)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  totalSupply(): BigInt {
    let result = super.call("totalSupply", "totalSupply():(uint256)", []);

    return result[0].toBigInt();
  }

  try_totalSupply(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("totalSupply", "totalSupply():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  transferFrom(_from: Address, _to: Address, _value: BigInt): boolean {
    let result = super.call(
      "transferFrom",
      "transferFrom(address,address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(_from),
        ethereum.Value.fromAddress(_to),
        ethereum.Value.fromUnsignedBigInt(_value)
      ]
    );

    return result[0].toBoolean();
  }

  try_transferFrom(
    _from: Address,
    _to: Address,
    _value: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "transferFrom",
      "transferFrom(address,address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(_from),
        ethereum.Value.fromAddress(_to),
        ethereum.Value.fromUnsignedBigInt(_value)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  recoverTokens(_value: BigInt): boolean {
    let result = super.call("recoverTokens", "recoverTokens(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(_value)
    ]);

    return result[0].toBoolean();
  }

  try_recoverTokens(_value: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "recoverTokens",
      "recoverTokens(uint256):(bool)",
      [ethereum.Value.fromUnsignedBigInt(_value)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  decimals(): i32 {
    let result = super.call("decimals", "decimals():(uint8)", []);

    return result[0].toI32();
  }

  try_decimals(): ethereum.CallResult<i32> {
    let result = super.tryCall("decimals", "decimals():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  etoken2(): Address {
    let result = super.call("etoken2", "etoken2():(address)", []);

    return result[0].toAddress();
  }

  try_etoken2(): ethereum.CallResult<Address> {
    let result = super.tryCall("etoken2", "etoken2():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getPendingVersionTimestamp(): BigInt {
    let result = super.call(
      "getPendingVersionTimestamp",
      "getPendingVersionTimestamp():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_getPendingVersionTimestamp(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getPendingVersionTimestamp",
      "getPendingVersionTimestamp():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  purgeUpgrade(): boolean {
    let result = super.call("purgeUpgrade", "purgeUpgrade():(bool)", []);

    return result[0].toBoolean();
  }

  try_purgeUpgrade(): ethereum.CallResult<boolean> {
    let result = super.tryCall("purgeUpgrade", "purgeUpgrade():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  optIn(): boolean {
    let result = super.call("optIn", "optIn():(bool)", []);

    return result[0].toBoolean();
  }

  try_optIn(): ethereum.CallResult<boolean> {
    let result = super.tryCall("optIn", "optIn():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  transferFromWithReference(
    _from: Address,
    _to: Address,
    _value: BigInt,
    _reference: string
  ): boolean {
    let result = super.call(
      "transferFromWithReference",
      "transferFromWithReference(address,address,uint256,string):(bool)",
      [
        ethereum.Value.fromAddress(_from),
        ethereum.Value.fromAddress(_to),
        ethereum.Value.fromUnsignedBigInt(_value),
        ethereum.Value.fromString(_reference)
      ]
    );

    return result[0].toBoolean();
  }

  try_transferFromWithReference(
    _from: Address,
    _to: Address,
    _value: BigInt,
    _reference: string
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "transferFromWithReference",
      "transferFromWithReference(address,address,uint256,string):(bool)",
      [
        ethereum.Value.fromAddress(_from),
        ethereum.Value.fromAddress(_to),
        ethereum.Value.fromUnsignedBigInt(_value),
        ethereum.Value.fromString(_reference)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  balanceOf(_owner: Address): BigInt {
    let result = super.call("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(_owner)
    ]);

    return result[0].toBigInt();
  }

  try_balanceOf(_owner: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(_owner)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  transferToICAP(_icap: Bytes, _value: BigInt): boolean {
    let result = super.call(
      "transferToICAP",
      "transferToICAP(bytes32,uint256):(bool)",
      [
        ethereum.Value.fromFixedBytes(_icap),
        ethereum.Value.fromUnsignedBigInt(_value)
      ]
    );

    return result[0].toBoolean();
  }

  try_transferToICAP(
    _icap: Bytes,
    _value: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "transferToICAP",
      "transferToICAP(bytes32,uint256):(bool)",
      [
        ethereum.Value.fromFixedBytes(_icap),
        ethereum.Value.fromUnsignedBigInt(_value)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  transferToICAPWithReference(
    _icap: Bytes,
    _value: BigInt,
    _reference: string
  ): boolean {
    let result = super.call(
      "transferToICAPWithReference",
      "transferToICAPWithReference(bytes32,uint256,string):(bool)",
      [
        ethereum.Value.fromFixedBytes(_icap),
        ethereum.Value.fromUnsignedBigInt(_value),
        ethereum.Value.fromString(_reference)
      ]
    );

    return result[0].toBoolean();
  }

  try_transferToICAPWithReference(
    _icap: Bytes,
    _value: BigInt,
    _reference: string
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "transferToICAPWithReference",
      "transferToICAPWithReference(bytes32,uint256,string):(bool)",
      [
        ethereum.Value.fromFixedBytes(_icap),
        ethereum.Value.fromUnsignedBigInt(_value),
        ethereum.Value.fromString(_reference)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  _forwardApprove(
    _spender: Address,
    _value: BigInt,
    _sender: Address
  ): boolean {
    let result = super.call(
      "_forwardApprove",
      "_forwardApprove(address,uint256,address):(bool)",
      [
        ethereum.Value.fromAddress(_spender),
        ethereum.Value.fromUnsignedBigInt(_value),
        ethereum.Value.fromAddress(_sender)
      ]
    );

    return result[0].toBoolean();
  }

  try__forwardApprove(
    _spender: Address,
    _value: BigInt,
    _sender: Address
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "_forwardApprove",
      "_forwardApprove(address,uint256,address):(bool)",
      [
        ethereum.Value.fromAddress(_spender),
        ethereum.Value.fromUnsignedBigInt(_value),
        ethereum.Value.fromAddress(_sender)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  symbol(): string {
    let result = super.call("symbol", "symbol():(string)", []);

    return result[0].toString();
  }

  try_symbol(): ethereum.CallResult<string> {
    let result = super.tryCall("symbol", "symbol():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  _forwardTransferFromToICAPWithReference(
    _from: Address,
    _icap: Bytes,
    _value: BigInt,
    _reference: string,
    _sender: Address
  ): boolean {
    let result = super.call(
      "_forwardTransferFromToICAPWithReference",
      "_forwardTransferFromToICAPWithReference(address,bytes32,uint256,string,address):(bool)",
      [
        ethereum.Value.fromAddress(_from),
        ethereum.Value.fromFixedBytes(_icap),
        ethereum.Value.fromUnsignedBigInt(_value),
        ethereum.Value.fromString(_reference),
        ethereum.Value.fromAddress(_sender)
      ]
    );

    return result[0].toBoolean();
  }

  try__forwardTransferFromToICAPWithReference(
    _from: Address,
    _icap: Bytes,
    _value: BigInt,
    _reference: string,
    _sender: Address
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "_forwardTransferFromToICAPWithReference",
      "_forwardTransferFromToICAPWithReference(address,bytes32,uint256,string,address):(bool)",
      [
        ethereum.Value.fromAddress(_from),
        ethereum.Value.fromFixedBytes(_icap),
        ethereum.Value.fromUnsignedBigInt(_value),
        ethereum.Value.fromString(_reference),
        ethereum.Value.fromAddress(_sender)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  transferFromToICAPWithReference(
    _from: Address,
    _icap: Bytes,
    _value: BigInt,
    _reference: string
  ): boolean {
    let result = super.call(
      "transferFromToICAPWithReference",
      "transferFromToICAPWithReference(address,bytes32,uint256,string):(bool)",
      [
        ethereum.Value.fromAddress(_from),
        ethereum.Value.fromFixedBytes(_icap),
        ethereum.Value.fromUnsignedBigInt(_value),
        ethereum.Value.fromString(_reference)
      ]
    );

    return result[0].toBoolean();
  }

  try_transferFromToICAPWithReference(
    _from: Address,
    _icap: Bytes,
    _value: BigInt,
    _reference: string
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "transferFromToICAPWithReference",
      "transferFromToICAPWithReference(address,bytes32,uint256,string):(bool)",
      [
        ethereum.Value.fromAddress(_from),
        ethereum.Value.fromFixedBytes(_icap),
        ethereum.Value.fromUnsignedBigInt(_value),
        ethereum.Value.fromString(_reference)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  transferFromToICAP(_from: Address, _icap: Bytes, _value: BigInt): boolean {
    let result = super.call(
      "transferFromToICAP",
      "transferFromToICAP(address,bytes32,uint256):(bool)",
      [
        ethereum.Value.fromAddress(_from),
        ethereum.Value.fromFixedBytes(_icap),
        ethereum.Value.fromUnsignedBigInt(_value)
      ]
    );

    return result[0].toBoolean();
  }

  try_transferFromToICAP(
    _from: Address,
    _icap: Bytes,
    _value: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "transferFromToICAP",
      "transferFromToICAP(address,bytes32,uint256):(bool)",
      [
        ethereum.Value.fromAddress(_from),
        ethereum.Value.fromFixedBytes(_icap),
        ethereum.Value.fromUnsignedBigInt(_value)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  etoken2Symbol(): Bytes {
    let result = super.call("etoken2Symbol", "etoken2Symbol():(bytes32)", []);

    return result[0].toBytes();
  }

  try_etoken2Symbol(): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "etoken2Symbol",
      "etoken2Symbol():(bytes32)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  getPendingVersion(): Address {
    let result = super.call(
      "getPendingVersion",
      "getPendingVersion():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_getPendingVersion(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getPendingVersion",
      "getPendingVersion():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  transfer(_to: Address, _value: BigInt): boolean {
    let result = super.call("transfer", "transfer(address,uint256):(bool)", [
      ethereum.Value.fromAddress(_to),
      ethereum.Value.fromUnsignedBigInt(_value)
    ]);

    return result[0].toBoolean();
  }

  try_transfer(_to: Address, _value: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall("transfer", "transfer(address,uint256):(bool)", [
      ethereum.Value.fromAddress(_to),
      ethereum.Value.fromUnsignedBigInt(_value)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  transferWithReference(
    _to: Address,
    _value: BigInt,
    _reference: string
  ): boolean {
    let result = super.call(
      "transferWithReference",
      "transferWithReference(address,uint256,string):(bool)",
      [
        ethereum.Value.fromAddress(_to),
        ethereum.Value.fromUnsignedBigInt(_value),
        ethereum.Value.fromString(_reference)
      ]
    );

    return result[0].toBoolean();
  }

  try_transferWithReference(
    _to: Address,
    _value: BigInt,
    _reference: string
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "transferWithReference",
      "transferWithReference(address,uint256,string):(bool)",
      [
        ethereum.Value.fromAddress(_to),
        ethereum.Value.fromUnsignedBigInt(_value),
        ethereum.Value.fromString(_reference)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  init(_etoken2: Address, _symbol: string, _name: string): boolean {
    let result = super.call("init", "init(address,string,string):(bool)", [
      ethereum.Value.fromAddress(_etoken2),
      ethereum.Value.fromString(_symbol),
      ethereum.Value.fromString(_name)
    ]);

    return result[0].toBoolean();
  }

  try_init(
    _etoken2: Address,
    _symbol: string,
    _name: string
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall("init", "init(address,string,string):(bool)", [
      ethereum.Value.fromAddress(_etoken2),
      ethereum.Value.fromString(_symbol),
      ethereum.Value.fromString(_name)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  proposeUpgrade(_newVersion: Address): boolean {
    let result = super.call(
      "proposeUpgrade",
      "proposeUpgrade(address):(bool)",
      [ethereum.Value.fromAddress(_newVersion)]
    );

    return result[0].toBoolean();
  }

  try_proposeUpgrade(_newVersion: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "proposeUpgrade",
      "proposeUpgrade(address):(bool)",
      [ethereum.Value.fromAddress(_newVersion)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  optOut(): boolean {
    let result = super.call("optOut", "optOut():(bool)", []);

    return result[0].toBoolean();
  }

  try_optOut(): ethereum.CallResult<boolean> {
    let result = super.tryCall("optOut", "optOut():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  allowance(_from: Address, _spender: Address): BigInt {
    let result = super.call(
      "allowance",
      "allowance(address,address):(uint256)",
      [ethereum.Value.fromAddress(_from), ethereum.Value.fromAddress(_spender)]
    );

    return result[0].toBigInt();
  }

  try_allowance(
    _from: Address,
    _spender: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "allowance",
      "allowance(address,address):(uint256)",
      [ethereum.Value.fromAddress(_from), ethereum.Value.fromAddress(_spender)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getVersionFor(_sender: Address): Address {
    let result = super.call(
      "getVersionFor",
      "getVersionFor(address):(address)",
      [ethereum.Value.fromAddress(_sender)]
    );

    return result[0].toAddress();
  }

  try_getVersionFor(_sender: Address): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getVersionFor",
      "getVersionFor(address):(address)",
      [ethereum.Value.fromAddress(_sender)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }
}

export class ApproveCall extends ethereum.Call {
  get inputs(): ApproveCall__Inputs {
    return new ApproveCall__Inputs(this);
  }

  get outputs(): ApproveCall__Outputs {
    return new ApproveCall__Outputs(this);
  }
}

export class ApproveCall__Inputs {
  _call: ApproveCall;

  constructor(call: ApproveCall) {
    this._call = call;
  }

  get _spender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _value(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class ApproveCall__Outputs {
  _call: ApproveCall;

  constructor(call: ApproveCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class CommitUpgradeCall extends ethereum.Call {
  get inputs(): CommitUpgradeCall__Inputs {
    return new CommitUpgradeCall__Inputs(this);
  }

  get outputs(): CommitUpgradeCall__Outputs {
    return new CommitUpgradeCall__Outputs(this);
  }
}

export class CommitUpgradeCall__Inputs {
  _call: CommitUpgradeCall;

  constructor(call: CommitUpgradeCall) {
    this._call = call;
  }
}

export class CommitUpgradeCall__Outputs {
  _call: CommitUpgradeCall;

  constructor(call: CommitUpgradeCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class _forwardTransferFromWithReferenceCall extends ethereum.Call {
  get inputs(): _forwardTransferFromWithReferenceCall__Inputs {
    return new _forwardTransferFromWithReferenceCall__Inputs(this);
  }

  get outputs(): _forwardTransferFromWithReferenceCall__Outputs {
    return new _forwardTransferFromWithReferenceCall__Outputs(this);
  }
}

export class _forwardTransferFromWithReferenceCall__Inputs {
  _call: _forwardTransferFromWithReferenceCall;

  constructor(call: _forwardTransferFromWithReferenceCall) {
    this._call = call;
  }

  get _from(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _to(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _value(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get _reference(): string {
    return this._call.inputValues[3].value.toString();
  }

  get _sender(): Address {
    return this._call.inputValues[4].value.toAddress();
  }
}

export class _forwardTransferFromWithReferenceCall__Outputs {
  _call: _forwardTransferFromWithReferenceCall;

  constructor(call: _forwardTransferFromWithReferenceCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class EmitApproveCall extends ethereum.Call {
  get inputs(): EmitApproveCall__Inputs {
    return new EmitApproveCall__Inputs(this);
  }

  get outputs(): EmitApproveCall__Outputs {
    return new EmitApproveCall__Outputs(this);
  }
}

export class EmitApproveCall__Inputs {
  _call: EmitApproveCall;

  constructor(call: EmitApproveCall) {
    this._call = call;
  }

  get _from(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _spender(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _value(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class EmitApproveCall__Outputs {
  _call: EmitApproveCall;

  constructor(call: EmitApproveCall) {
    this._call = call;
  }
}

export class TransferFromCall extends ethereum.Call {
  get inputs(): TransferFromCall__Inputs {
    return new TransferFromCall__Inputs(this);
  }

  get outputs(): TransferFromCall__Outputs {
    return new TransferFromCall__Outputs(this);
  }
}

export class TransferFromCall__Inputs {
  _call: TransferFromCall;

  constructor(call: TransferFromCall) {
    this._call = call;
  }

  get _from(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _to(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _value(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class TransferFromCall__Outputs {
  _call: TransferFromCall;

  constructor(call: TransferFromCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class EmitTransferCall extends ethereum.Call {
  get inputs(): EmitTransferCall__Inputs {
    return new EmitTransferCall__Inputs(this);
  }

  get outputs(): EmitTransferCall__Outputs {
    return new EmitTransferCall__Outputs(this);
  }
}

export class EmitTransferCall__Inputs {
  _call: EmitTransferCall;

  constructor(call: EmitTransferCall) {
    this._call = call;
  }

  get _from(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _to(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _value(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class EmitTransferCall__Outputs {
  _call: EmitTransferCall;

  constructor(call: EmitTransferCall) {
    this._call = call;
  }
}

export class RecoverTokensCall extends ethereum.Call {
  get inputs(): RecoverTokensCall__Inputs {
    return new RecoverTokensCall__Inputs(this);
  }

  get outputs(): RecoverTokensCall__Outputs {
    return new RecoverTokensCall__Outputs(this);
  }
}

export class RecoverTokensCall__Inputs {
  _call: RecoverTokensCall;

  constructor(call: RecoverTokensCall) {
    this._call = call;
  }

  get _value(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class RecoverTokensCall__Outputs {
  _call: RecoverTokensCall;

  constructor(call: RecoverTokensCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class PurgeUpgradeCall extends ethereum.Call {
  get inputs(): PurgeUpgradeCall__Inputs {
    return new PurgeUpgradeCall__Inputs(this);
  }

  get outputs(): PurgeUpgradeCall__Outputs {
    return new PurgeUpgradeCall__Outputs(this);
  }
}

export class PurgeUpgradeCall__Inputs {
  _call: PurgeUpgradeCall;

  constructor(call: PurgeUpgradeCall) {
    this._call = call;
  }
}

export class PurgeUpgradeCall__Outputs {
  _call: PurgeUpgradeCall;

  constructor(call: PurgeUpgradeCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class OptInCall extends ethereum.Call {
  get inputs(): OptInCall__Inputs {
    return new OptInCall__Inputs(this);
  }

  get outputs(): OptInCall__Outputs {
    return new OptInCall__Outputs(this);
  }
}

export class OptInCall__Inputs {
  _call: OptInCall;

  constructor(call: OptInCall) {
    this._call = call;
  }
}

export class OptInCall__Outputs {
  _call: OptInCall;

  constructor(call: OptInCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class TransferFromWithReferenceCall extends ethereum.Call {
  get inputs(): TransferFromWithReferenceCall__Inputs {
    return new TransferFromWithReferenceCall__Inputs(this);
  }

  get outputs(): TransferFromWithReferenceCall__Outputs {
    return new TransferFromWithReferenceCall__Outputs(this);
  }
}

export class TransferFromWithReferenceCall__Inputs {
  _call: TransferFromWithReferenceCall;

  constructor(call: TransferFromWithReferenceCall) {
    this._call = call;
  }

  get _from(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _to(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _value(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get _reference(): string {
    return this._call.inputValues[3].value.toString();
  }
}

export class TransferFromWithReferenceCall__Outputs {
  _call: TransferFromWithReferenceCall;

  constructor(call: TransferFromWithReferenceCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class TransferToICAPCall extends ethereum.Call {
  get inputs(): TransferToICAPCall__Inputs {
    return new TransferToICAPCall__Inputs(this);
  }

  get outputs(): TransferToICAPCall__Outputs {
    return new TransferToICAPCall__Outputs(this);
  }
}

export class TransferToICAPCall__Inputs {
  _call: TransferToICAPCall;

  constructor(call: TransferToICAPCall) {
    this._call = call;
  }

  get _icap(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get _value(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class TransferToICAPCall__Outputs {
  _call: TransferToICAPCall;

  constructor(call: TransferToICAPCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class TransferToICAPWithReferenceCall extends ethereum.Call {
  get inputs(): TransferToICAPWithReferenceCall__Inputs {
    return new TransferToICAPWithReferenceCall__Inputs(this);
  }

  get outputs(): TransferToICAPWithReferenceCall__Outputs {
    return new TransferToICAPWithReferenceCall__Outputs(this);
  }
}

export class TransferToICAPWithReferenceCall__Inputs {
  _call: TransferToICAPWithReferenceCall;

  constructor(call: TransferToICAPWithReferenceCall) {
    this._call = call;
  }

  get _icap(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get _value(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get _reference(): string {
    return this._call.inputValues[2].value.toString();
  }
}

export class TransferToICAPWithReferenceCall__Outputs {
  _call: TransferToICAPWithReferenceCall;

  constructor(call: TransferToICAPWithReferenceCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class _forwardApproveCall extends ethereum.Call {
  get inputs(): _forwardApproveCall__Inputs {
    return new _forwardApproveCall__Inputs(this);
  }

  get outputs(): _forwardApproveCall__Outputs {
    return new _forwardApproveCall__Outputs(this);
  }
}

export class _forwardApproveCall__Inputs {
  _call: _forwardApproveCall;

  constructor(call: _forwardApproveCall) {
    this._call = call;
  }

  get _spender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _value(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get _sender(): Address {
    return this._call.inputValues[2].value.toAddress();
  }
}

export class _forwardApproveCall__Outputs {
  _call: _forwardApproveCall;

  constructor(call: _forwardApproveCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class _forwardTransferFromToICAPWithReferenceCall extends ethereum.Call {
  get inputs(): _forwardTransferFromToICAPWithReferenceCall__Inputs {
    return new _forwardTransferFromToICAPWithReferenceCall__Inputs(this);
  }

  get outputs(): _forwardTransferFromToICAPWithReferenceCall__Outputs {
    return new _forwardTransferFromToICAPWithReferenceCall__Outputs(this);
  }
}

export class _forwardTransferFromToICAPWithReferenceCall__Inputs {
  _call: _forwardTransferFromToICAPWithReferenceCall;

  constructor(call: _forwardTransferFromToICAPWithReferenceCall) {
    this._call = call;
  }

  get _from(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _icap(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get _value(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get _reference(): string {
    return this._call.inputValues[3].value.toString();
  }

  get _sender(): Address {
    return this._call.inputValues[4].value.toAddress();
  }
}

export class _forwardTransferFromToICAPWithReferenceCall__Outputs {
  _call: _forwardTransferFromToICAPWithReferenceCall;

  constructor(call: _forwardTransferFromToICAPWithReferenceCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class TransferFromToICAPWithReferenceCall extends ethereum.Call {
  get inputs(): TransferFromToICAPWithReferenceCall__Inputs {
    return new TransferFromToICAPWithReferenceCall__Inputs(this);
  }

  get outputs(): TransferFromToICAPWithReferenceCall__Outputs {
    return new TransferFromToICAPWithReferenceCall__Outputs(this);
  }
}

export class TransferFromToICAPWithReferenceCall__Inputs {
  _call: TransferFromToICAPWithReferenceCall;

  constructor(call: TransferFromToICAPWithReferenceCall) {
    this._call = call;
  }

  get _from(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _icap(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get _value(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get _reference(): string {
    return this._call.inputValues[3].value.toString();
  }
}

export class TransferFromToICAPWithReferenceCall__Outputs {
  _call: TransferFromToICAPWithReferenceCall;

  constructor(call: TransferFromToICAPWithReferenceCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class TransferFromToICAPCall extends ethereum.Call {
  get inputs(): TransferFromToICAPCall__Inputs {
    return new TransferFromToICAPCall__Inputs(this);
  }

  get outputs(): TransferFromToICAPCall__Outputs {
    return new TransferFromToICAPCall__Outputs(this);
  }
}

export class TransferFromToICAPCall__Inputs {
  _call: TransferFromToICAPCall;

  constructor(call: TransferFromToICAPCall) {
    this._call = call;
  }

  get _from(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _icap(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get _value(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class TransferFromToICAPCall__Outputs {
  _call: TransferFromToICAPCall;

  constructor(call: TransferFromToICAPCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class TransferCall extends ethereum.Call {
  get inputs(): TransferCall__Inputs {
    return new TransferCall__Inputs(this);
  }

  get outputs(): TransferCall__Outputs {
    return new TransferCall__Outputs(this);
  }
}

export class TransferCall__Inputs {
  _call: TransferCall;

  constructor(call: TransferCall) {
    this._call = call;
  }

  get _to(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _value(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class TransferCall__Outputs {
  _call: TransferCall;

  constructor(call: TransferCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class TransferWithReferenceCall extends ethereum.Call {
  get inputs(): TransferWithReferenceCall__Inputs {
    return new TransferWithReferenceCall__Inputs(this);
  }

  get outputs(): TransferWithReferenceCall__Outputs {
    return new TransferWithReferenceCall__Outputs(this);
  }
}

export class TransferWithReferenceCall__Inputs {
  _call: TransferWithReferenceCall;

  constructor(call: TransferWithReferenceCall) {
    this._call = call;
  }

  get _to(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _value(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get _reference(): string {
    return this._call.inputValues[2].value.toString();
  }
}

export class TransferWithReferenceCall__Outputs {
  _call: TransferWithReferenceCall;

  constructor(call: TransferWithReferenceCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class InitCall extends ethereum.Call {
  get inputs(): InitCall__Inputs {
    return new InitCall__Inputs(this);
  }

  get outputs(): InitCall__Outputs {
    return new InitCall__Outputs(this);
  }
}

export class InitCall__Inputs {
  _call: InitCall;

  constructor(call: InitCall) {
    this._call = call;
  }

  get _etoken2(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _symbol(): string {
    return this._call.inputValues[1].value.toString();
  }

  get _name(): string {
    return this._call.inputValues[2].value.toString();
  }
}

export class InitCall__Outputs {
  _call: InitCall;

  constructor(call: InitCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class ProposeUpgradeCall extends ethereum.Call {
  get inputs(): ProposeUpgradeCall__Inputs {
    return new ProposeUpgradeCall__Inputs(this);
  }

  get outputs(): ProposeUpgradeCall__Outputs {
    return new ProposeUpgradeCall__Outputs(this);
  }
}

export class ProposeUpgradeCall__Inputs {
  _call: ProposeUpgradeCall;

  constructor(call: ProposeUpgradeCall) {
    this._call = call;
  }

  get _newVersion(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class ProposeUpgradeCall__Outputs {
  _call: ProposeUpgradeCall;

  constructor(call: ProposeUpgradeCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class OptOutCall extends ethereum.Call {
  get inputs(): OptOutCall__Inputs {
    return new OptOutCall__Inputs(this);
  }

  get outputs(): OptOutCall__Outputs {
    return new OptOutCall__Outputs(this);
  }
}

export class OptOutCall__Inputs {
  _call: OptOutCall;

  constructor(call: OptOutCall) {
    this._call = call;
  }
}

export class OptOutCall__Outputs {
  _call: OptOutCall;

  constructor(call: OptOutCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}
